use crate::engine::ast::{å‘½ä»¤, å¼};
use std::cell::RefCell;
use std::collections::HashMap;

pub struct Evaluator {
    å‡ºåŠ›ãƒãƒƒãƒ•ã‚¡: RefCell<String>,
    è¨˜æ†¶é ˜åŸŸ: RefCell<HashMap<String, å€¤>>, 
}

#[derive(Debug, Clone, PartialEq)]
pub enum å€¤ { æ•°å€¤(f64), æ–‡å­—åˆ—(String), ç©º }

impl Evaluator {
    pub fn new() -> Self {
        Self {
            å‡ºåŠ›ãƒãƒƒãƒ•ã‚¡: RefCell::new(String::new()),
            è¨˜æ†¶é ˜åŸŸ: RefCell::new(HashMap::new()),
        }
    }

    pub fn å®Ÿè¡Œ(&self, å‘½ä»¤ã‚»ãƒƒãƒˆ: Vec<å‘½ä»¤>) -> String {
        for cmd in å‘½ä»¤ã‚»ãƒƒãƒˆ { self.å‘½ä»¤ã‚’å®Ÿè¡Œ(cmd); }
        self.å‡ºåŠ›ãƒãƒƒãƒ•ã‚¡.borrow().clone()
    }

    fn å‘½ä»¤ã‚’å®Ÿè¡Œ(&self, cmd: å‘½ä»¤) {
        match cmd {
            å‘½ä»¤::å¤‰æ•°å®£è¨€ { åå‰, å€¤ } | å‘½ä»¤::ä»£å…¥æ–‡ { åå‰, å€¤ } => {
                let è©•ä¾¡å€¤ = self.è©•ä¾¡(å€¤);
                self.è¨˜æ†¶é ˜åŸŸ.borrow_mut().insert(åå‰, è©•ä¾¡å€¤);
            }
            å‘½ä»¤::ã‚‚ã—æ–‡ { æ¡ä»¶, å®Ÿè¡Œå†…å®¹, ã•ã‚‚ãªãã° } => {
                if self.è«–ç†è©•ä¾¡(æ¡ä»¶) {
                    for å†…å´ã®å‘½ä»¤ in å®Ÿè¡Œå†…å®¹ { self.å‘½ä»¤ã‚’å®Ÿè¡Œ(å†…å´ã®å‘½ä»¤); }
                } else {
                    for å†…å´ã®å‘½ä»¤ in ã•ã‚‚ãªãã° { self.å‘½ä»¤ã‚’å®Ÿè¡Œ(å†…å´ã®å‘½ä»¤); }
                }
            }

            å‘½ä»¤::ç¹°ã‚Šè¿”ã—æ–‡ { æ¡ä»¶, å®Ÿè¡Œå†…å®¹ } => {
                // æ¡ä»¶ãŒæº€ãŸã•ã‚Œã¦ã„ã‚‹é–“ã€ãšã£ã¨å›ã—ã¾ã™
                // â€» æ¡ä»¶å¼ã‚„å‘½ä»¤ã¯ãƒ«ãƒ¼ãƒ—ã®ãŸã³ã«è©•ä¾¡ã™ã‚‹ãŸã‚ clone ã—ã¦ä½¿ã„ã¾ã™
                while self.è«–ç†è©•ä¾¡(æ¡ä»¶.clone()) {
                    for å†…å´ã®å‘½ä»¤ in &å®Ÿè¡Œå†…å®¹ {
                        self.å‘½ä»¤ã‚’å®Ÿè¡Œ(å†…å´ã®å‘½ä»¤.clone());
                    }
                    
                    // â€» ç„¡é™ãƒ«ãƒ¼ãƒ—é˜²æ­¢ã®ãŸã‚ã®å®‰å…¨è£…ç½®ï¼ˆã‚«ã‚¦ãƒ³ã‚¿ãªã©ï¼‰ã‚’
                    //    å°†æ¥çš„ã«ã“ã“ã¸å…¥ã‚Œã‚‹ã¨è‰¯ã„ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚
                }
            }


            å‘½ä»¤::è¡¨ç¤ºæ–‡(å†…å®¹) => {
                let è©•ä¾¡çµæœ = self.è©•ä¾¡(å†…å®¹);
                let mut buffer = self.å‡ºåŠ›ãƒãƒƒãƒ•ã‚¡.borrow_mut();
                let è¡¨ç¤ºãƒ†ã‚­ã‚¹ãƒˆ = match è©•ä¾¡çµæœ {
                    å€¤::æ•°å€¤(n) => n.to_string(),
                    å€¤::æ–‡å­—åˆ—(s) => s,
                    å€¤::ç©º => "ï¼ˆç©ºï¼‰".to_string(),
                };
                buffer.push_str(&format!("ã€å‡ºåŠ›ã€‘: {}\n", è¡¨ç¤ºãƒ†ã‚­ã‚¹ãƒˆ));
            }
            å‘½ä»¤::è¨˜éŒ²æ–‡ => {
                let mut buffer = self.å‡ºåŠ›ãƒãƒƒãƒ•ã‚¡.borrow_mut();
                buffer.push_str("ã€è¨˜éŒ²ä¸­ã€‘: å¤‰æ›´ã‚’ä¿å­˜ã—ã¦ã„ã¾ã™...\n");
                let _ = std::process::Command::new("git").args(["add", "."]).output();
                let _ = std::process::Command::new("git").args(["commit", "-m", "å…«ç™¾ä¸‡ã‚¨ãƒ‡ã‚£ã‚¿ã‹ã‚‰ã®è‡ªå‹•è¨˜éŒ²"]).output();
                buffer.push_str("ã€å®Œäº†ã€‘: è¨˜éŒ²ã•ã‚Œã¾ã—ãŸã€‚ğŸŒ¸\n");
            }
            å‘½ä»¤::é€ä¿¡æ–‡ => {
                let mut buffer = self.å‡ºåŠ›ãƒãƒƒãƒ•ã‚¡.borrow_mut();
                buffer.push_str("ã€é€ä¿¡ä¸­ã€‘: GitHubã¸é€ã‚Šå±Šã‘ã¦ã„ã¾ã™...\n");
                let _ = std::process::Command::new("git").args(["push", "origin", "main"]).output();
                buffer.push_str("ã€å®Œäº†ã€‘: é€ä¿¡ãŒå®Œäº†ã—ã¾ã—ãŸã€‚ğŸš€\n");
            }
        }
    }

    fn è«–ç†è©•ä¾¡(&self, expr: å¼) -> bool {
        match expr {
            å¼::æ¯”è¼ƒ { å·¦è¾º, æ¼”ç®—å­, å³è¾º } => {
                let å·¦ = self.è©•ä¾¡(*å·¦è¾º);
                let å³ = self.è©•ä¾¡(*å³è¾º);
                
                let å·¦ã®å€¤ = match &å·¦ { å€¤::æ•°å€¤(n) => *n, _ => 0.0 };
                let å³ã®å€¤ = match &å³ { å€¤::æ•°å€¤(n) => *n, _ => 0.0 };

                if æ¼”ç®—å­ == "ï¼" {
                     match (å·¦, å³) {
                        (å€¤::æ•°å€¤(a), å€¤::æ•°å€¤(b)) => a == b,
                        (å€¤::æ–‡å­—åˆ—(a), å€¤::æ–‡å­—åˆ—(b)) => a == b,
                        _ => false
                    }
                } else if æ¼”ç®—å­ == "ï¼" {
                    å·¦ã®å€¤ > å³ã®å€¤
                } else if æ¼”ç®—å­ == "ï¼œ" {
                    å·¦ã®å€¤ < å³ã®å€¤
                } else {
                    false
                }
            }
            _ => match self.è©•ä¾¡(expr) {
                å€¤::æ•°å€¤(n) => n != 0.0,
                å€¤::æ–‡å­—åˆ—(s) => !s.is_empty(),
                å€¤::ç©º => false,
            },
        }
    }

    fn è©•ä¾¡(&self, expr: å¼) -> å€¤ {
        match expr {
            å¼::å¤‰æ•°(åå‰) => self.è¨˜æ†¶é ˜åŸŸ.borrow().get(&åå‰).cloned().unwrap_or(å€¤::ç©º),
            å¼::æ•°å€¤(n) => å€¤::æ•°å€¤(n),
            å¼::æ–‡å­—åˆ—(s) => å€¤::æ–‡å­—åˆ—(s),
            å¼::è¨ˆç®— { å·¦è¾º, æ¼”ç®—å­, å³è¾º } => {
                let å·¦ = match self.è©•ä¾¡(*å·¦è¾º) { å€¤::æ•°å€¤(n) => n, _ => 0.0 };
                let å³ = match self.è©•ä¾¡(*å³è¾º) { å€¤::æ•°å€¤(n) => n, _ => 0.0 };
                let çµæœ = match æ¼”ç®—å­ {
                    '+' => å·¦ + å³, '-' => å·¦ - å³, '*' => å·¦ * å³,
                    '/' => if å³ != 0.0 { å·¦ / å³ } else { 0.0 },
                    _ => 0.0,
                };
                å€¤::æ•°å€¤(çµæœ)
            }
            å¼::æ¯”è¼ƒ { .. } => { if self.è«–ç†è©•ä¾¡(expr) { å€¤::æ•°å€¤(1.0) } else { å€¤::æ•°å€¤(0.0) } }
        }
    }
}